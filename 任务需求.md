

---

## 0. 目标产物（最终你要拿到什么）

1. 一个 Web 页面（输入框）
2. 一个 Go 后端服务（HTTP API）
3. Nginx 反向代理 + HTTPS
4. systemd 服务（开机自启、崩溃自动拉起）
5. 一份可执行部署任务（脚本或逐条命令）用于 VPS 上安装/配置/启动

---

## 1. 功能需求（前端 + 后端）

### 1.1 输入

* 一个 textarea 输入框
* 支持多条链接，分隔符：

  * 逗号 `,`（含中文逗号 `，` 也要支持）
  * 换行
  * 可混用
* 支持协议：

  * `vless://`
  * `vmess://`

### 1.2 输出（两个框）

* 输出框 A：**Clash proxies 节点行**（按输入顺序逐行输出）

  * 每条输出为单行字典格式：

    * `- {name: xxx, type: vless, server: ..., port: ..., uuid: ..., cipher: none, network: tcp, tls: false, udp: true}`
    * vmess 输出同理（`type: vmess`，包含 `uuid`/`alterId`/`cipher` 等）
* 输出框 B：**proxy-groups 的 proxies 引用行**（按输入顺序逐行输出）

  * `- "节点名"`
* 顺序要求：严格保持输入顺序
* 空 token：忽略（不输出，不报错）
* 失败 token：不影响其他成功项，给出错误提示（显示第几条、原因）

### 1.3 解析规则（MVP）

#### VLESS

* 从 `uuid@host:port` 提取：

  * `uuid`, `server`, `port`
* query：

  * `type` -> `network`（默认 tcp）
  * `security`：

    * `none` => `tls: false`
    * `tls/reality` => `tls: true`（高级字段先不展开）
  * `encryption=none` => `cipher: none`
* `#` 后备注名：URL decode；为空则生成默认名（如 `vless-<server>-<port>`）
* 输出字段最小集合：`name,type,server,port,uuid,cipher,network,tls,udp`

#### VMESS

* `vmess://` 后 base64 解码 JSON
* 常用字段：

  * `ps` -> name（无则生成）
  * `add` -> server
  * `port`
  * `id` -> uuid
  * `aid` -> alterId
  * `net` -> network（默认 tcp）
  * `tls` -> tls（"tls" => true，否则 false）
  * `scy` -> cipher（无则 auto）
* 输出字段最小集合：`name,type,server,port,uuid,alterId,cipher,network,tls,udp`
* ws/grpc/sni/path/host 等高级字段：MVP 可不输出，但解析要容错（可在返回中提示“高级参数未展开”）

---

## 2. API 设计（Go 后端）

### 2.1 Endpoint

* `POST /api/convert`

  * Request JSON:

    * `{ "input": "..." }`
  * Response JSON:

    * `{
      "proxy_lines": "...\n...",
      "group_lines": "...\n...",
      "errors": [{"index": 3, "value": "...", "message": "..."}]
      }`

### 2.2 运行模式

* Go 服务监听：`127.0.0.1:7625`
* 无状态，不落盘，不记录明文输入到日志

### 2.3 保护

* 输入大小限制（例如 200KB）
* 每次请求最大条数限制（例如 500 条）
* 基本 rate limit 交给 Nginx 做（见部署）

---

## 3. Web 页面（前端）

### 3.1 页面结构

* 输入 textarea
* 按钮：

  * 转换
  * 清空
  * 复制“节点输出”
  * 复制“组内输出”
* 输出 textarea A（proxy_lines）
* 输出 textarea B（group_lines）
* 错误区域（errors 列表）

### 3.2 调用方式

* 前端 fetch 调用 `/api/convert`
* 渲染返回的两段输出 + 错误列表

> 前端可用纯 HTML/JS（最轻量），由 Go 直接 embed 或由 Nginx 静态托管均可。

---

## 4. Nginx 反代与 HTTPS

### 4.1 反向代理

* `/`：静态页面（index.html）
* `/api/`：反代到 `http://127.0.0.1:7625`

### 4.2 基础安全与限流

* 限制请求体大小：`client_max_body_size 256k;`
* rate limit（按 IP）：

  * `limit_req_zone` + `limit_req`
* 添加基础安全 header（可选）

### 4.3 TLS

* 用 Let’s Encrypt（推荐 `certbot --nginx` 或 `acme.sh`）
* 强制 HTTP->HTTPS

---

## 5. systemd 服务（Go 常驻）

* 可执行文件放在：`/opt/link2clash/link2clash`
* 配置：

  * `Restart=always`
  * `User=www-data` 或自建低权限用户
  * `WorkingDirectory=/opt/link2clash`
  * `Environment=PORT=8080`（可选）

---

## 6. **新增：需要执行的任务（可直接在 VPS 上跑的部署清单/脚本）**

### 6.1 手工命令清单（逐条复制执行）

包含：

1. 安装 Nginx、certbot（或 acme.sh）
2. 创建目录 `/opt/link2clash`
3. 上传/放置二进制 + 静态文件
4. 写 systemd unit 文件并启用
5. 写 Nginx server block 并启用
6. 申请证书并重载 Nginx
7. 验证：

   * `curl https://yourdomain/api/convert`



---

## 7. 目录结构建议（交付清晰）

* `/opt/link2clash/`

  * `link2clash`（Go 二进制）
  * `static/`

    * `index.html`
    * `app.js`
    * `style.css`（可选）
* `/etc/systemd/system/link2clash.service`
* `/etc/nginx/sites-available/link2clash.conf`
* `/etc/nginx/sites-enabled/link2clash.conf`（软链）

---

## 8. 验收标准（你自己检查）

1. 打开网页能输入多条 vless/vmess
2. 点击转换能得到两个输出框：

   * proxies lines：`- {name: ...}` 每条一行
   * group lines：`- "name"` 每条一行
3. 输入顺序保持一致
4. 任意一条坏链接不会影响其他条
5. `systemctl status link2clash` 正常
6. Nginx HTTPS 正常，且 `/api/convert` 可访问

---



* 无域名：先 HTTP 跑通 + 后续加域名再切 HTTPS

